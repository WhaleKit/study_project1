#ifndef ACTIONONENTITY_H
#define ACTIONONENTITY_H



/*чтобы обеспечить независимость хода от порядка обновления в главном цикле
я запрещаю энтити напрямую действовать на другие энтити, и, вместо этого, они
говорят движку, что с ними делать, и движок выполняет действия ПОСЛЕ обновления всех энтити

Энтити записывают действия в специальный стэк, а под них - данные, если такие есть.


Из-за того, что у стека может кончится место, он может перенести все данные  другой буффер,
из-за чего абсолютные адреса этих объектов могут "слететь".
Зато гарантируется постоянство адресов действия относительно друг друга и их порядок.
Это позволяет нескольким "действиям" разделять общие данные.
Например: складываем действие 1, затем действие 2. 2 выполняется первым, оно
ориентируясь за счет своего адреса идет к данным действия 1, записывает туда что-то,
затем действие 1 исходит из этих данных - "отчета" от действия 2.
Например - эффект "вампиризма" - "лечебная" часть должна знать, сколько урона нанесла
"повреждающая"
*/

struct ActionOnEntity
{
    typedef  void (*ActionFunction) (Entity* subject, void* data);
    ActionFunction action;
    unsigned subjectNum;
    size_t dataSize;
};
#endif // ACTIONONENTITY_H
