#ifndef ACTIONONENTITY_H
#define ACTIONONENTITY_H



/*чтобы обеспечить независимость хода от порядка обновления в главном цикле
я запрещаю энтити напрямую действовать на другие энтити, и, вместо этого, они
говорят движку, что с ними делать, и движок выполняет действия ПОСЛЕ обновления всех энтити

Энтити записывают действия в специальный стэк, а под них - данные, если такие есть.


Из-за того, что у стека может кончится место, он может перенести все данные  другой буффер,
из-за чего абсолютные адреса этих объектов могут "слететь".
Зато гарантируется постоянство адресов действия относительно друг друга и их порядок.
Это позволяет нескольким "действиям" разделять общие данные.
Например: складываем действие 1, затем действие 2. 2 выполняется первым, оно
ориентируясь за счет своего адреса идет к данным действия 1, записывает туда что-то (отчет),
затем действие 1 исходит из этих данных.
*/

/*Вот какполная запись действия вместе с параметрами выглядит в памяти в стэке:
Структура ActionOnEntity, с указателем на функцию, числом субъектов и размером доп. данных
под ней список субъектов этого действия (в виде номеров) в формате size_t
под ней дополнительные данные

дополнительные данные - это параметры действия. Функция интерпретирует их на свое усмотрение.
Например,  действия "удар" несет количество и характер урона (мы же не хотим плодить отдельные функции
для нанесения 1, 2, 3, и тд ед урона.)

когда действие выполняется, на основе списка номеров субъектов формируется список указателей на них
и указатель на этот список передается в функцию вместе с указателем на объект, данные и числом субъетов

Почему не сделать субъеты частью данных?
 Потому что неконстантные указатели на них нельзя получить в методе entity::act(), только номера.
 Это сделано, чтотбы энтити не вздумали ничего менять в других энтити в методе act,
 (это нарушило бы независимость от порядка прохода по контейнеру энтити.)
 Все действия над другими только через систему планирования.
*/

struct ActionOnEntity
{
    typedef  void (*ActionFunction) (Entity* object, Entity** subjectsList, size_t subjectsNum, void* data);
    ActionOnEntity () {};
    ActionOnEntity (ActionFunction af_arg, Entity const* obj_arg, size_t numberOfSubj_arg = 1
                    ,size_t dataSize_arg = 0)
    : actionFn(af_arg), object(obj_arg), numberOfSubjects(numberOfSubj_arg), dataSize(dataSize_arg)
    {

    }
    ActionFunction actionFn=nullptr;
    Entity const* object=nullptr;

    size_t numberOfSubjects=1;
    size_t dataSize=0;

    size_t SizeWithAllData()
    {
        return sizeof(ActionOnEntity) + numberOfSubjects * sizeof(size_t) + dataSize;
    }
    size_t SizeWithSubjectsListOnly ()
    {
        return (sizeof(ActionOnEntity) + numberOfSubjects * sizeof(size_t));
    }
};






#endif // ACTIONONENTITY_H
